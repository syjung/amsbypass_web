<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AMS Bypass Query Application</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        <!-- Flash Messages -->
        {% with messages = get_flashed_messages(with_categories=true) %}
            {% if messages %}
                <div class="flash-messages">
                    {% for category, message in messages %}
                        <div class="flash-message flash-{{ category }}">
                            {{ message }}
                        </div>
                    {% endfor %}
                </div>
            {% endif %}
        {% endwith %}

        <!-- Search Form -->
        <section class="search-section">
            <h2>üîç Search Criteria</h2>
            <form method="POST" action="{{ url_for('search') }}" class="search-form search-form-inline">
                <div class="form-group-inline">
                    <label for="ship_id">Ship ID <span class="required">*</span></label>
                    <input type="text" 
                           id="ship_id" 
                           name="ship_id" 
                           value="{{ ship_id or '' }}" 
                           required 
                           placeholder="Enter ship ID">
                </div>

                <div class="form-group-inline">
                    <label for="from_date">From Date <span class="optional">(Optional)</span></label>
                    <input type="datetime-local" 
                           id="from_date" 
                           name="from_date" 
                           value="{{ from_date or '' }}" 
                           placeholder="YYYY-MM-DDTHH:MM">
                </div>

                <div class="form-group-inline">
                    <label for="to_date">To Date <span class="optional">(Optional)</span></label>
                    <input type="datetime-local" 
                           id="to_date" 
                           name="to_date" 
                           value="{{ to_date or '' }}" 
                           placeholder="YYYY-MM-DDTHH:MM">
                </div>

                <div class="form-group-inline">
                    <label for="refresh_interval">Refresh Interval (sec) <span class="optional">(Optional)</span></label>
                    <input type="number" 
                           id="refresh_interval" 
                           name="refresh_interval" 
                           value="{{ refresh_interval or '5' }}" 
                           min="1" 
                           max="300" 
                           placeholder="5">
                </div>

                <div class="form-actions-inline">
                    <button type="submit" class="btn btn-primary" id="search-btn">
                        <span id="search-text">üîç Search</span>
                        <span id="search-loading" style="display: none;">‚è≥ Searching...</span>
                    </button>
                    <button type="button" class="btn btn-secondary" id="reset-btn" onclick="resetForm()">üîÑ Reset</button>
                    <button type="button" class="btn btn-realtime" id="realtime-btn" onclick="toggleRealtime()">
                        <span id="realtime-text">‚è∏Ô∏è RealTime</span>
                    </button>
                </div>
            </form>
            
            <!-- RealTime Status -->
            <div id="realtime-status" class="realtime-status" style="display: none;">
                <span class="realtime-badge">‚ñ∂Ô∏è RealTime ON</span>
                <span id="realtime-last-update" class="realtime-last-update"></span>
            </div>
        </section>

        <!-- Loading Overlay -->
        <div id="loading-overlay" style="display: none;">
            <div class="loading-spinner">
                <div class="spinner"></div>
                <p>Querying database... Please wait</p>
            </div>
        </div>

        <!-- Results Section -->
        {% if table_rows %}
        <section class="results-section" id="results-section">
            <h2>üìä Search Results</h2>
            <p class="result-count" id="result-count">
                {% set start_row = ((page - 1) * records_per_page) + 1 %}
                {% set end_row = ((page - 1) * records_per_page) + table_rows|length %}
                Showing {{ start_row }} - {{ end_row }} of {{ total_count }} row(s) found
            </p>

            <div class="table-container">
                <table class="excel-table" id="data-table">
                    <thead>
                        <tr>
                            <th>Ship ID</th>
                            <th>TagName</th>
                            <th>Value</th>
                            <th>Description</th>
                            <th>Unit</th>
                            <th>CreatedTime (UTC)</th>
                        </tr>
                    </thead>
                    <tbody id="table-body">
                        {% for row in table_rows %}
                        <tr>
                            <td>{{ row.ship_id }}</td>
                            <td><strong>{{ row.tag_name }}</strong></td>
                            <td>
                                {% set value_type = row.value_type if row.value_type is defined else 'str' %}
                                {% if value_type == 'bool' %}
                                    <span class="value-boolean value-{{ 'true' if row.value else 'false' }}">{{ row.value }}</span>
                                {% elif value_type == 'int' or value_type == 'float' %}
                                    <span class="value-number">{{ row.value }}</span>
                                {% else %}
                                    <span class="value-text">{{ row.value }}</span>
                                {% endif %}
                            </td>
                            <td>{{ row.description }}</td>
                            <td>{{ row.unit }}</td>
                            <td>{{ row.posix_micros }}</td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>

            <!-- Pagination -->
            {% if total_pages > 1 %}
            <div class="pagination">
                <form method="GET" action="{{ url_for('search') }}" id="pagination-form">
                    <input type="hidden" name="ship_id" value="{{ ship_id }}">
                    {% if from_date %}
                    <input type="hidden" name="from_date" value="{{ from_date }}">
                    {% endif %}
                    {% if to_date %}
                    <input type="hidden" name="to_date" value="{{ to_date }}">
                    {% endif %}
                    {% if refresh_interval %}
                    <input type="hidden" name="refresh_interval" value="{{ refresh_interval }}">
                    {% endif %}
                    
                    <div class="pagination-controls">
                        {% if page > 1 %}
                        <button type="submit" name="page" value="{{ page - 1 }}" class="btn-pagination">‚óÄ Previous</button>
                        {% else %}
                        <button type="button" class="btn-pagination disabled" disabled>‚óÄ Previous</button>
                        {% endif %}
                        
                        <span class="page-info">Page {{ page }} of {{ total_pages }}</span>
                        
                        {% if page < total_pages %}
                        <button type="submit" name="page" value="{{ page + 1 }}" class="btn-pagination">Next ‚ñ∂</button>
                        {% else %}
                        <button type="button" class="btn-pagination disabled" disabled>Next ‚ñ∂</button>
                        {% endif %}
                    </div>
                </form>
            </div>
            {% endif %}
        </section>
        {% endif %}

        <footer>
            <p>¬© 2025 AMS Bypass Query Application</p>
        </footer>
    </div>

    <script>
        // RealTime variables
        let realtimeMode = false;
        let pollInterval = null;
        let lastTimestamp = null;
        const MAX_ROWS = 500; // Maximum rows to display in realtime mode
        let POLL_INTERVAL = 5000; // Default 5 seconds

        // Set today's date/time as default if not already set
        window.onload = function() {
            const now = new Date();
            // Format as datetime-local (YYYY-MM-DDTHH:MM) in local time
            // Convert UTC to local for display
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const today = `${year}-${month}-${day}T${hours}:${minutes}`;
            
            const fromDate = document.getElementById('from_date');
            const toDate = document.getElementById('to_date');
            
            if (!fromDate.value) {
                fromDate.value = today;
            }
            if (!toDate.value) {
                toDate.value = today;
            }
        };

        function resetForm() {
            const now = new Date();
            // Format as datetime-local in local time
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const today = `${year}-${month}-${day}T${hours}:${minutes}`;
            
            document.getElementById('ship_id').value = '';
            document.getElementById('from_date').value = today;
            document.getElementById('to_date').value = today;
            document.getElementById('refresh_interval').value = '5';
            
            // Stop realtime if active
            if (realtimeMode) {
                stopRealtime();
            }
        }

        // RealTime functions
        function toggleRealtime() {
            if (realtimeMode) {
                stopRealtime();
            } else {
                startRealtime();
            }
        }

        function startRealtime() {
            const shipId = document.getElementById('ship_id').value.trim();
            if (!shipId) {
                alert('Please enter Ship ID first');
                return;
            }

            // Get refresh interval from input
            const refreshIntervalInput = document.getElementById('refresh_interval');
            const intervalSeconds = parseInt(refreshIntervalInput.value) || 5;
            POLL_INTERVAL = intervalSeconds * 1000; // Convert to milliseconds

            realtimeMode = true;
            const realtimeBtn = document.getElementById('realtime-btn');
            const realtimeText = document.getElementById('realtime-text');
            const realtimeStatus = document.getElementById('realtime-status');
            const searchForm = document.querySelector('.search-form-inline');
            const pagination = document.querySelector('.pagination');
            const tableBody = document.getElementById('table-body');
            const resultsSection = document.getElementById('results-section');
            const resultCount = document.getElementById('result-count');

            // Create results section and table if they don't exist (for direct RealTime without Search)
            if (!resultsSection) {
                // Find the container
                const container = document.querySelector('.container');
                if (container) {
                    // Create results section
                    const newResultsSection = document.createElement('section');
                    newResultsSection.className = 'results-section';
                    newResultsSection.id = 'results-section';
                    newResultsSection.innerHTML = `
                        <h2>üìä Search Results</h2>
                        <p class="result-count" id="result-count">RealTime Mode: Waiting for new data...</p>
                        <div class="table-container">
                            <table class="excel-table" id="data-table">
                                <thead>
                                    <tr>
                                        <th>Ship ID</th>
                                        <th>TagName</th>
                                        <th>Value</th>
                                        <th>Description</th>
                                        <th>Unit</th>
                                        <th>CreatedTime (UTC)</th>
                                    </tr>
                                </thead>
                                <tbody id="table-body"></tbody>
                            </table>
                        </div>
                    `;
                    // Insert before footer
                    const footer = document.querySelector('footer');
                    if (footer) {
                        container.insertBefore(newResultsSection, footer);
                    } else {
                        container.appendChild(newResultsSection);
                    }
                }
            } else {
                // Clear existing table rows if table exists
                const tableBodyEl = document.getElementById('table-body');
                if (tableBodyEl) {
                    tableBodyEl.innerHTML = '';
                }
                // Show results section if it exists
                resultsSection.style.display = 'block';
            }

            // Update result count
            const resultCountEl = document.getElementById('result-count');
            if (resultCountEl) {
                resultCountEl.textContent = 'RealTime Mode: Waiting for new data...';
            }

            // Update UI
            realtimeBtn.classList.add('active');
            realtimeText.textContent = '‚ñ∂Ô∏è RealTime ON';
            realtimeStatus.style.display = 'inline-flex';
            
            // Disable search form inputs (but keep RealTime button clickable)
            const formInputs = searchForm.querySelectorAll('input, button[type="submit"], button#reset-btn');
            formInputs.forEach(input => {
                input.disabled = true;
                input.style.opacity = '0.6';
                input.style.cursor = 'not-allowed';
            });
            
            // Ensure RealTime button remains clickable
            realtimeBtn.style.pointerEvents = 'auto';
            realtimeBtn.style.opacity = '1';
            realtimeBtn.disabled = false;
            
            // Hide pagination
            if (pagination) {
                pagination.style.display = 'none';
            }

            // Initialize last timestamp (1 minute ago in local timezone - to get recent data)
            const now = new Date();
            const oneMinuteAgo = new Date(now.getTime() - 60 * 1000); // 1 minute ago
            // Use local time
            const year = oneMinuteAgo.getFullYear();
            const month = String(oneMinuteAgo.getMonth() + 1).padStart(2, '0');
            const day = String(oneMinuteAgo.getDate()).padStart(2, '0');
            const hours = String(oneMinuteAgo.getHours()).padStart(2, '0');
            const minutes = String(oneMinuteAgo.getMinutes()).padStart(2, '0');
            const seconds = String(oneMinuteAgo.getSeconds()).padStart(2, '0');
            lastTimestamp = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;

            // Start polling immediately
            pollRealtimeData();
            pollInterval = setInterval(pollRealtimeData, POLL_INTERVAL);
        }

        function stopRealtime() {
            realtimeMode = false;
            const realtimeBtn = document.getElementById('realtime-btn');
            const realtimeText = document.getElementById('realtime-text');
            const realtimeStatus = document.getElementById('realtime-status');
            const searchForm = document.querySelector('.search-form-inline');
            const pagination = document.querySelector('.pagination');

            // Clear interval
            if (pollInterval) {
                clearInterval(pollInterval);
                pollInterval = null;
            }

            // Update UI
            realtimeBtn.classList.remove('active');
            realtimeText.textContent = '‚è∏Ô∏è RealTime';
            realtimeStatus.style.display = 'none';
            
            // Enable search form inputs
            const formInputs = searchForm.querySelectorAll('input, button[type="submit"], button#reset-btn');
            formInputs.forEach(input => {
                input.disabled = false;
                input.style.opacity = '1';
                input.style.cursor = '';
            });
            
            // Reset RealTime button style
            realtimeBtn.style.pointerEvents = '';
            realtimeBtn.style.opacity = '';
            
            // Show pagination
            if (pagination) {
                pagination.style.display = 'block';
            }

            lastTimestamp = null;
        }

        async function pollRealtimeData() {
            if (!realtimeMode) return;

            const shipId = document.getElementById('ship_id').value.trim();
            
            if (!shipId) {
                stopRealtime();
                return;
            }

            try {
                // Build query string
                let queryParams = `ship_id=${encodeURIComponent(shipId)}`;
                if (lastTimestamp) {
                    queryParams += `&last_timestamp=${encodeURIComponent(lastTimestamp)}`;
                }

                // Fetch new data
                const response = await fetch(`/api/realtime?${queryParams}`);
                const data = await response.json();

                if (!data.success) {
                    console.error('Realtime API error:', data.error);
                    return;
                }

                // Clear previous highlights before adding new rows
                const tbody = document.getElementById('table-body');
                if (tbody) {
                    const allRows = tbody.querySelectorAll('tr.new-row-highlight');
                    allRows.forEach(row => {
                        row.classList.remove('new-row-highlight');
                    });
                }

                // Always update last update time
                updateLastUpdateTime();
                
                // Get count of new rows added in this refresh
                const newRowsCount = data.new_rows ? data.new_rows.length : 0;
                
                // Update table with new rows
                if (newRowsCount > 0) {
                    updateTableWithNewRows(data.new_rows, newRowsCount);
                    
                    // Update last timestamp (convert UTC to local time for next query)
                    if (data.last_timestamp) {
                        // data.last_timestamp is in UTC format 'YYYY-MM-DD HH:MM:SS'
                        // Convert to local time for next query
                        try {
                            // Parse UTC timestamp: 'YYYY-MM-DD HH:MM:SS' -> Date object
                            // Replace space with 'T' and add 'Z' for UTC
                            const utcString = data.last_timestamp.replace(' ', 'T') + 'Z';
                            const utcDate = new Date(utcString);
                            
                            // Convert to local time
                            const year = utcDate.getFullYear();
                            const month = String(utcDate.getMonth() + 1).padStart(2, '0');
                            const day = String(utcDate.getDate()).padStart(2, '0');
                            const hours = String(utcDate.getHours()).padStart(2, '0');
                            const minutes = String(utcDate.getMinutes()).padStart(2, '0');
                            const seconds = String(utcDate.getSeconds()).padStart(2, '0');
                            lastTimestamp = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
                            
                            console.log(`Updated lastTimestamp: UTC ${data.last_timestamp} -> Local ${lastTimestamp}`);
                        } catch (e) {
                            console.error('Error converting last_timestamp:', e);
                            // If conversion fails, use as-is
                            lastTimestamp = data.last_timestamp;
                        }
                    }
                } else {
                    // No new data, but keep the last_timestamp from server (don't update to current time)
                    // This ensures we don't skip data if there's a delay
                    if (data.last_timestamp) {
                        try {
                            // Parse UTC timestamp and convert to local time
                            const utcString = data.last_timestamp.replace(' ', 'T') + 'Z';
                            const utcDate = new Date(utcString);
                            const year = utcDate.getFullYear();
                            const month = String(utcDate.getMonth() + 1).padStart(2, '0');
                            const day = String(utcDate.getDate()).padStart(2, '0');
                            const hours = String(utcDate.getHours()).padStart(2, '0');
                            const minutes = String(utcDate.getMinutes()).padStart(2, '0');
                            const seconds = String(utcDate.getSeconds()).padStart(2, '0');
                            lastTimestamp = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
                        } catch (e) {
                            console.error('Error converting last_timestamp:', e);
                        }
                    }
                    // Update result count even when no new rows
                    updateResultCount(0, 0);
                }
            } catch (error) {
                console.error('Error polling realtime data:', error);
            }
        }

        function updateTableWithNewRows(newRows, newRowsCount) {
            const tbody = document.getElementById('table-body');
            if (!tbody) {
                // Create tbody if it doesn't exist (for realtime mode)
                const table = document.getElementById('data-table');
                if (table) {
                    const newTbody = document.createElement('tbody');
                    newTbody.id = 'table-body';
                    table.appendChild(newTbody);
                    return updateTableWithNewRows(newRows, newRowsCount); // Retry with new tbody
                }
                return;
            }

            // Ensure results section is visible
            const resultsSection = document.getElementById('results-section');
            if (resultsSection && newRows.length > 0) {
                resultsSection.style.display = 'block';
            }

            // Create rows for new data with staggered animation
            newRows.forEach((row, index) => {
                const tr = document.createElement('tr');
                tr.className = 'new-row new-row-highlight'; // For animation and persistent highlight
                
                // Add staggered delay for multiple rows
                tr.style.animationDelay = `${index * 0.05}s`;

                // Format value based on type
                let valueHtml = '';
                const valueType = row.value_type || 'str';
                if (valueType === 'bool') {
                    const boolClass = row.value ? 'true' : 'false';
                    valueHtml = `<span class="value-boolean value-${boolClass}">${row.value}</span>`;
                } else if (valueType === 'int' || valueType === 'float') {
                    valueHtml = `<span class="value-number">${row.value}</span>`;
                } else {
                    valueHtml = `<span class="value-text">${row.value}</span>`;
                }

                tr.innerHTML = `
                    <td>${escapeHtml(row.ship_id || '')}</td>
                    <td><strong>${escapeHtml(row.tag_name || '')}</strong></td>
                    <td>${valueHtml}</td>
                    <td>${escapeHtml(row.description || '')}</td>
                    <td>${escapeHtml(row.unit || '')}</td>
                    <td>${escapeHtml(row.posix_micros || '')}</td>
                `;

                // Insert at the beginning (top of table)
                tbody.insertBefore(tr, tbody.firstChild);

                // Remove animation class after animation completes, but keep highlight until next refresh
                setTimeout(() => {
                    tr.classList.remove('new-row');
                    tr.style.animationDelay = ''; // Clear delay
                }, 1500); // Match animation duration (1.5s)
            });

            // Limit maximum rows
            const allRows = tbody.querySelectorAll('tr');
            if (allRows.length > MAX_ROWS) {
                for (let i = MAX_ROWS; i < allRows.length; i++) {
                    allRows[i].remove();
                }
            }

            // Update result count with total and new rows count
            const currentRowCount = tbody.querySelectorAll('tr').length;
            updateResultCount(currentRowCount, newRowsCount);
        }

        // Helper function to escape HTML
        function escapeHtml(text) {
            if (text === null || text === undefined) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function updateResultCount(totalCount, newRowsCount) {
            const resultCount = document.getElementById('result-count');
            if (resultCount) {
                if (realtimeMode) {
                    if (newRowsCount > 0) {
                        resultCount.innerHTML = `Total: <strong>${totalCount}</strong> row(s) | <span style="color: #ff9800; font-weight: bold;">+${newRowsCount} new</span> (RealTime Mode)`;
                    } else {
                        resultCount.textContent = `Total: ${totalCount} row(s) | +0 new (RealTime Mode)`;
                    }
                } else {
                    // Keep original count if not in realtime mode
                    // This function is mainly for realtime mode
                }
            }
        }

        function updateLastUpdateTime() {
            const lastUpdateEl = document.getElementById('realtime-last-update');
            if (lastUpdateEl) {
                const now = new Date();
                // Display in UTC
                const utcTime = now.toISOString().replace('T', ' ').substring(0, 19) + ' UTC';
                lastUpdateEl.textContent = `Last update: ${utcTime}`;
            }
        }

        // Show loading indicator when form is submitted
        document.querySelector('.search-form-inline').addEventListener('submit', function(e) {
            // Stop realtime if active
            if (realtimeMode) {
                stopRealtime();
            }

            // Use datetime-local values as-is (no timezone conversion)

            const loadingOverlay = document.getElementById('loading-overlay');
            const searchBtn = document.getElementById('search-btn');
            const searchText = document.getElementById('search-text');
            const searchLoading = document.getElementById('search-loading');
            
            // Show loading overlay
            loadingOverlay.style.display = 'flex';
            
            // Update button text
            searchText.style.display = 'none';
            searchLoading.style.display = 'inline';
            searchBtn.disabled = true;
            
            // Prevent form resubmission
            searchBtn.style.pointerEvents = 'none';
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            if (realtimeMode && pollInterval) {
                clearInterval(pollInterval);
            }
        });
    </script>
</body>
</html>

